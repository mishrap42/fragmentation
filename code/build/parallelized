if (!require('binsreg')) install.packages("binsreg")

library(here)        # Manage file paths relative to project root
library(sf)          # Spatial data handling (reading shapefiles, geometric operations)
library(ggplot2)     # Data visualization and plotting
library(dplyr)       # Data manipulation (filtering, grouping, summarizing)
library(gridExtra)   # Arrange multiple plots side-by-side
library(readxl)      # Read Excel files
library(binsreg)     # Binned regression plots
library(lubridate)   # Date/time manipulation
library(Hmisc)       # Miscellaneous data analysis functions
library(fixest)      # Fast fixed-effects regressions
library(countrycode) # Convert country codes/names
library(parallel)

if (grepl("ahaanj", here())) {
  dropbox_dir <- "/Users/ahaanj/Dartmouth College Dropbox/Ahaan Jindal/Protected Area Fragmentation/"
} else if (grepl("mishrap", here())) {
  dropbox_dir <- "/Users/mishrap/Dropbox (Personal)/Protected Area Fragmentation/"
} else {
  stop("Username not recognized. Please update the script with your Dropbox path.")
}

intermediate_data_dir = file.path(dropbox_dir, 'Data/build')
figure_dir = file.path(dropbox_dir, 'Figures', '1_calculate_shapes')
if (!dir.exists(figure_dir)) dir.create(figure_dir, recursive = TRUE)

pa <- st_read(paste0(dropbox_dir, 'Data/raw/protected sites/protectedsites.shp'))

# Get a stratified sample - 50 areas from each country
set.seed(123)
pa_sample <- pa %>%
  group_by(legalFound, cddaCountr) %>%
  slice_sample(n = 5) %>%
  ungroup()

cat("Total sampled areas:", nrow(pa_sample), "\n")

print('Country counts: validation of sampling')
pa_sample %>% st_drop_geometry() %>% group_by(cddaCountr) %>% summarise(n = n()) %>% print(n = Inf)

print('Foundation year counts:')
pa_sample %>% st_drop_geometry() %>% group_by(legalFound) %>% summarise(n = n()) %>% print(n = Inf)

print('Checking shape validity:')
pa_sample$valid <- st_is_valid(pa_sample)
sprintf('Number of valid geometries: %d out of %d\n', sum( (pa_sample %>% st_drop_geometry())$valid), nrow(pa_sample))

# ========== NINA'S SHAPE METRICS - CORRECTED IMPLEMENTATION ==========
# All require sampling points and computing pairwise distances

# Function to sample interior points from a polygon
sample_interior_points <- function(geom, n_points = 100) {
  # Generate random points inside the polygon
  points <- st_sample(geom, size = n_points, type = "random")
  return(points)
}

# Function to sample perimeter points from a polygon
sample_perimeter_points <- function(geom, n_points = 100) {
  # Cast to linestring and sample along the boundary
  boundary <- st_cast(st_boundary(geom), "LINESTRING")
  points <- st_line_sample(boundary, n = n_points)
  # st_line_sample returns multipoint, convert to individual points
  points <- st_cast(points, "POINT")
  return(points)
}

# Calculate shape metrics for all protected areas
pa_sample <- pa_sample %>%
  mutate(
    area_km2 = as.numeric(units::set_units(st_area(geometry), "km^2")),
    perimeter_km = as.numeric(units::set_units(st_length(st_cast(geometry, "MULTILINESTRING")), "km"))
  ) 

pa_centroid = pa_sample %>% st_centroid() %>% st_coordinates() %>% as.data.frame()

point_sample = sample_interior_points(pa_sample$geometry[1], n_points = 100)

# Visualize sampled points and centroid for the first polygon
p <- ggplot() + geom_sf(data = pa_sample[1,], fill = "lightgreen", color = "darkgreen") +
  geom_sf(data = point_sample, color = "red", size = 2) +
  geom_point(data = as.data.frame(pa_centroid[1,]), aes(x = X, y = Y), color = "blue", size = 3) +
  theme_minimal()
ggsave(file.path(figure_dir, "example_point_sampling.png"), p, width = 8, height = 6)

# P. 3 of Nina's appendix:
dist_matrix = units::set_units(st_distance(point_sample, point_sample), "km")
example_disconnection_index = sum(dist_matrix, na.rm = TRUE) / (nrow(dist_matrix) * (nrow(dist_matrix) - 1))

# Process in chunks of 100. TODO: parallelize this.

# Function to process one chunk
chunk_size <- 10
n_total <- nrow(pa_sample)
n_chunks <- ceiling(n_total / chunk_size)
pa_sample_shapes <- list()

for (i in 1:10) {  # Test with 2 first
  start_idx <- (i - 1) * chunk_size + 1
  end_idx <- min(i * chunk_size, n_total)
  
  cat(sprintf("Processing chunk %d of %d (rows %d to %d)...\n", i, n_chunks, start_idx, end_idx))
  
  chunk = pa_sample[start_idx:end_idx, ]
  chunk_result <- chunk %>%
    rowwise() %>%
    mutate(
      interior_pts = list(sample_interior_points(geometry, n_points = 100))
    ) %>%
    mutate(
      dist_matrix = list(units::set_units(st_distance(interior_pts, interior_pts), "km")),
      dist_to_centroid = list(units::set_units(st_distance(interior_pts, st_centroid(geometry)), "km"))
    ) %>%
    mutate(
      disconnection_index = as.numeric(sum(dist_matrix, na.rm = TRUE) / (nrow(dist_matrix) * (nrow(dist_matrix) - 1))),
      remoteness = as.numeric(mean(dist_to_centroid, na.rm = TRUE)),
      spin = as.numeric(mean(dist_to_centroid^2, na.rm = TRUE)),
      range_km = as.numeric(units::set_units(st_length(st_cast(st_convex_hull(geometry), "LINESTRING")), "km"))
    ) %>%
    select(-interior_pts, -dist_matrix, -dist_to_centroid) %>%
    ungroup()
  
  pa_sample_shapes[[i]] <- chunk_result
}

pa_sample_shapes <- bind_rows(pa_sample_shapes)

st_write(pa_sample_shapes, paste0(intermediate_data_dir, '/pa_sample_shapes.shp'), delete_dsn = TRUE)

View(pa_sample_shapes)

# Create list of plots
metrics <- list(
  list(col = "disconnection_index", title = "Disconnection", fill = "lightblue"),
  list(col = "remoteness", title = "Remoteness", fill = "lightcoral"),
  list(col = "spin", title = "Spin", fill = "lightgreen"),
  list(col = "range_km", title = "Range", fill = "lightyellow")
)

plots <- lapply(metrics, function(m) {
  pa_sample_shapes %>% st_drop_geometry() %>% filter(!!sym(m$col) > 0) %>%
    ggplot(aes(x = !!sym(m$col))) + 
    geom_histogram(bins = 30, fill = m$fill, color = "black") +
    scale_x_log10() + theme_minimal() + 
    labs(title = m$title, x = "km (log)", y = "Count")
})

grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_histogram_grid.png"), grid_plot, width = 12, height = 10)

# Compare the actual values
pa_sample_shapes %>%
  st_drop_geometry() %>%
  select(disconnection_index, remoteness, spin, range_km) %>%
  summary()

# Add countryname once
pa_sample_shapes$countryname <- countrycode(pa_sample_shapes$cddaCountr, origin = 'eurostat', destination = 'country.name')

# 1. Histograms (already done)
metrics <- list(
  list(col = "disconnection_index", title = "Disconnection", fill = "lightblue"),
  list(col = "remoteness", title = "Remoteness", fill = "lightcoral"),
  list(col = "spin", title = "Spin", fill = "lightgreen"),
  list(col = "range_km", title = "Range", fill = "lightyellow")
)

plots <- lapply(metrics, function(m) {
  pa_sample_shapes %>% st_drop_geometry() %>% filter(!!sym(m$col) > 0) %>%
    ggplot(aes(x = !!sym(m$col))) + 
    geom_histogram(bins = 30, fill = m$fill, color = "black") +
    scale_x_log10() + theme_minimal() + 
    labs(title = m$title, x = "km (log)", y = "Count")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_histograms.png"), grid_plot, width = 12, height = 10)

# 2. Mean by Country (2x2)
plots <- lapply(metrics, function(m) {
  pa_sample_shapes %>%
    st_drop_geometry() %>%
    group_by(countryname) %>%
    summarise(mean_val = mean(!!sym(m$col), na.rm = TRUE)) %>%
    ggplot(aes(x = reorder(countryname, mean_val), y = mean_val)) +
    geom_col(fill = m$fill, color = "black") +
    coord_flip() + theme_minimal() +
    labs(title = m$title, x = "", y = "")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_by_country.png"), grid_plot, width = 14, height = 12)

# 3. Trend over time (2x2)
plots <- lapply(metrics, function(m) {
  pa_sample_shapes %>%
    filter(legalFound > 0 & legalFound < 2030) %>%
    st_drop_geometry() %>%
    group_by(legalFound) %>%
    summarise(mean_val = mean(!!sym(m$col), na.rm = TRUE)) %>%
    ggplot(aes(x = legalFound, y = mean_val)) +
    geom_col(fill = m$fill, color = "black") +
    theme_minimal() +
    labs(title = m$title, x = "Year", y = "")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_by_year.png"), grid_plot, width = 12, height = 10)


# 4. Area-Residualized by Country (2x2)
plots <- lapply(metrics, function(m) {
  resid_model <- feols(as.formula(paste(m$col, "~ i(countryname) + log(area_km2) - 1")),
                       data = pa_sample_shapes %>% st_drop_geometry() %>% 
                         filter(legalFound > 0 & legalFound < 2030))
  
  country_coefs <- data.frame(
    countryname = gsub("countryname::", "", names(coef(resid_model))[grepl("countryname", names(coef(resid_model)))]),
    residualized = coef(resid_model)[grepl("countryname", names(coef(resid_model)))]
  )
  
  country_coefs %>%
    ggplot(aes(x = reorder(countryname, residualized), y = residualized)) +
    geom_col(fill = m$fill, color = "black") +
    coord_flip() + theme_minimal() +
    labs(title = m$title, x = "", y = "")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_residualized.png"), grid_plot, width = 14, height = 12)

# 5. Decomposition Stacked (2x2)
plots <- lapply(metrics, function(m) {
  # Get mean by country
  country_mean <- pa_sample_shapes %>%
    st_drop_geometry() %>%
    group_by(countryname) %>%
    summarise(mean_val = mean(!!sym(m$col), na.rm = TRUE))
  
  # Get residualized
  resid_model <- feols(as.formula(paste(m$col, "~ i(countryname) + log(area_km2) - 1")),
                       data = pa_sample_shapes %>% st_drop_geometry() %>% 
                         filter(legalFound > 0 & legalFound < 2030))
  
  country_coefs <- data.frame(
    countryname = gsub("countryname::", "", names(coef(resid_model))[grepl("countryname", names(coef(resid_model)))]),
    residualized = coef(resid_model)[grepl("countryname", names(coef(resid_model)))]
  )
  
  # Merge and decompose
  decomp <- country_mean %>%
    left_join(country_coefs, by = "countryname") %>%
    mutate(
      area_effect = mean_val - residualized,
      true_effect = residualized
    )
  
  decomp_long <- rbind(
    decomp %>% mutate(component = "true_effect", value = true_effect),
    decomp %>% mutate(component = "area_effect", value = area_effect)
  )
  
  decomp_long %>%
    ggplot(aes(x = reorder(countryname, mean_val), y = value, fill = component)) +
    geom_col() +
    coord_flip() +
    scale_fill_manual(values = c("true_effect" = "steelblue", "area_effect" = "coral")) +
    theme_minimal() +
    theme(legend.position = "none") +
    labs(title = m$title, x = "", y = "")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_decomposition.png"), grid_plot, width = 14, height = 12)


# Visualize the most disconnected region (residualized on area)
disconnection_model <- lm(disconnection_index ~ poly(area_km2, 5), data = pa_sample_shapes %>% st_drop_geometry())
pa_sample_shapes$disconnection_residual <- residuals(disconnection_model)

most_disconnected_idx <- which.max(pa_sample_shapes$disconnection_residual)
most_disconnected <- pa_sample_shapes[most_disconnected_idx, ]
most_disconnected_pts <- sample_interior_points(most_disconnected$geometry, n_points = 100)
most_disconnected_centroid <- st_centroid(most_disconnected$geometry)

p_disconnected <- ggplot() +
  geom_sf(data = most_disconnected, fill = "lightblue", color = "darkblue", linewidth = 1) +
  geom_sf(data = most_disconnected_pts, color = "red", size = 1.5, alpha = 0.6) +
  geom_sf(data = most_disconnected_centroid, color = "darkgreen", size = 4, shape = 17) +
  theme_minimal() +
  labs(title = sprintf("Most Disconnected Region (Residualized on Area)\nIndex: %.2f km | Residual: %.2f",
                       most_disconnected$disconnection_index, most_disconnected$disconnection_residual),
       subtitle = sprintf("Country: %s, Area: %.2f km²",
                         most_disconnected$cddaCountr, most_disconnected$area_km2))
ggsave(file.path(figure_dir, "most_disconnected_region.png"), p_disconnected, width = 10, height = 8)

# Residualize all metrics on area for exemplar pairs analysis
pa_sample_shapes_resid <- pa_sample_shapes %>% st_drop_geometry()

metrics_to_residualize <- c("disconnection_index", "remoteness", "spin")
for (metric in metrics_to_residualize) {
  model <- lm(as.formula(paste(metric, "~ poly(area_km2, 5)")), data = pa_sample_shapes_resid)
  pa_sample_shapes[[paste0(metric, "_resid")]] <- residuals(model)
}

# Find exemplar pairs: regions with different disconnection but same other metrics
find_exemplar_pair <- function(data, metric_name, tolerance = 0.1) {
  # For each pair of regions, check if they match on the metric but differ in disconnection
  metric_col <- data[[paste0(metric_name, "_resid")]]
  disc_col <- data$disconnection_index_resid

  best_pair <- NULL
  best_disc_diff <- 0

  for (i in 1:(nrow(data)-1)) {
    for (j in (i+1):nrow(data)) {
      metric_diff <- abs(metric_col[i] - metric_col[j]) / (sd(metric_col, na.rm = TRUE) + 1e-10)
      disc_diff <- abs(disc_col[i] - disc_col[j])

      if (metric_diff < tolerance && disc_diff > best_disc_diff) {
        best_disc_diff <- disc_diff
        best_pair <- c(i, j)
      }
    }
  }

  return(best_pair)
}

# Find pairs for each metric
cat("\n=== SEARCHING FOR EXEMPLAR PAIRS (RESIDUALIZED ON AREA) ===\n")

metrics_to_check <- c("remoteness", "spin")
exemplar_pairs <- list()

for (metric in metrics_to_check) {
  cat(sprintf("\nSearching for pair with same %s but different disconnection...\n", metric))
  pair <- find_exemplar_pair(pa_sample_shapes, metric, tolerance = 0.1)

  if (!is.null(pair)) {
    i1 <- pair[1]
    i2 <- pair[2]
    cat(sprintf("  Found pair: rows %d and %d\n", i1, i2))
    cat(sprintf("    %s (raw): %.3f vs %.3f\n",
                metric,
                pa_sample_shapes[[metric]][i1],
                pa_sample_shapes[[metric]][i2]))
    cat(sprintf("    %s (resid): %.3f vs %.3f\n",
                metric,
                pa_sample_shapes[[paste0(metric, "_resid")]][i1],
                pa_sample_shapes[[paste0(metric, "_resid")]][i2]))
    cat(sprintf("    disconnection (raw): %.3f vs %.3f\n",
                pa_sample_shapes$disconnection_index[i1],
                pa_sample_shapes$disconnection_index[i2]))
    cat(sprintf("    disconnection (resid): %.3f vs %.3f (diff: %.3f)\n",
                pa_sample_shapes$disconnection_index_resid[i1],
                pa_sample_shapes$disconnection_index_resid[i2],
                abs(pa_sample_shapes$disconnection_index_resid[i1] - pa_sample_shapes$disconnection_index_resid[i2])))
    exemplar_pairs[[metric]] <- pair
  } else {
    cat(sprintf("  No suitable pair found for %s\n", metric))
  }
}

# Visualize exemplar pairs
for (metric in names(exemplar_pairs)) {
  pair <- exemplar_pairs[[metric]]

  regions <- pa_sample_shapes[pair, ]

  plots_list <- list()
  for (i in 1:2) {
    region <- regions[i, ]
    pts <- sample_interior_points(region$geometry, n_points = 100)
    centroid <- st_centroid(region$geometry)

    p <- ggplot() +
      geom_sf(data = region, fill = "lightblue", color = "darkblue", linewidth = 1) +
      geom_sf(data = pts, color = "red", size = 1, alpha = 0.5) +
      geom_sf(data = centroid, color = "darkgreen", size = 3, shape = 17) +
      theme_minimal() +
      labs(title = sprintf("Region %d: Disconnection (resid) = %.2f", i, region[[paste0("disconnection_index_resid")]]),
           subtitle = sprintf("%s (resid) = %.2f | Area = %.1f km²", metric, region[[paste0(metric, "_resid")]], region$area_km2))

    plots_list[[i]] <- p
  }

  combined <- grid.arrange(grobs = plots_list, ncol = 2,
                          top = sprintf("Same %s, Different Disconnection", toupper(metric)))
  ggsave(file.path(figure_dir, sprintf("exemplar_pair_%s.png", metric)),
         combined, width = 16, height = 8)
}

# Try to find a triple match (all 3 metrics similar but different disconnection)
cat("\n=== SEARCHING FOR TRIPLE MATCH (same remoteness & spin, residualized) ===\n")
best_triple_pair <- NULL
best_triple_disc_diff <- 0

remoteness_sd <- sd(pa_sample_shapes$remoteness_resid, na.rm = TRUE)
spin_sd <- sd(pa_sample_shapes$spin_resid, na.rm = TRUE)

for (i in 1:(nrow(pa_sample_shapes)-1)) {
  for (j in (i+1):nrow(pa_sample_shapes)) {
    remoteness_match <- abs(pa_sample_shapes$remoteness_resid[i] -
      pa_sample_shapes$remoteness_resid[j]) / remoteness_sd < 0.15
    spin_match <- abs(pa_sample_shapes$spin_resid[i] -
      pa_sample_shapes$spin_resid[j]) / spin_sd < 0.15

    disc_diff <- abs(pa_sample_shapes$disconnection_index_resid[i] -
      pa_sample_shapes$disconnection_index_resid[j])

    if (remoteness_match && spin_match && disc_diff > best_triple_disc_diff) {
      best_triple_disc_diff <- disc_diff
      best_triple_pair <- c(i, j)
    }
  }
}

if (!is.null(best_triple_pair)) {
  i1 <- best_triple_pair[1]
  i2 <- best_triple_pair[2]
  cat(sprintf("Found triple match: rows %d and %d\n", i1, i2))
  cat(sprintf("  remoteness (raw): %.3f vs %.3f\n",
              pa_sample_shapes$remoteness[i1], pa_sample_shapes$remoteness[i2]))
  cat(sprintf("  remoteness (resid): %.3f vs %.3f\n",
              pa_sample_shapes$remoteness_resid[i1],
              pa_sample_shapes$remoteness_resid[i2]))
  cat(sprintf("  spin (raw): %.3f vs %.3f\n",
              pa_sample_shapes$spin[i1], pa_sample_shapes$spin[i2]))
  cat(sprintf("  spin (resid): %.3f vs %.3f\n",
              pa_sample_shapes$spin_resid[i1], pa_sample_shapes$spin_resid[i2]))
  cat(sprintf("  disconnection (raw): %.3f vs %.3f\n",
              pa_sample_shapes$disconnection_index[i1],
              pa_sample_shapes$disconnection_index[i2]))
  cat(sprintf("  disconnection (resid): %.3f vs %.3f (diff: %.3f)\n",
              pa_sample_shapes$disconnection_index_resid[i1],
              pa_sample_shapes$disconnection_index_resid[i2],
              best_triple_disc_diff))

  regions <- pa_sample_shapes[best_triple_pair, ]
  plots_list <- list()
  for (i in 1:2) {
    region <- regions[i, ]
    pts <- sample_interior_points(region$geometry, n_points = 100)
    centroid <- st_centroid(region$geometry)

    p <- ggplot() +
      geom_sf(data = region, fill = "lightcoral", color = "darkred",
              linewidth = 1) +
      geom_sf(data = pts, color = "blue", size = 1, alpha = 0.5) +
      geom_sf(data = centroid, color = "darkgreen", size = 3, shape = 17) +
      theme_minimal() +
      labs(title = sprintf("Region %d: Disconnection (resid) = %.2f",
                           i, region$disconnection_index_resid),
           subtitle = sprintf("Remoteness (resid)=%.2f | Spin (resid)=%.2f",
                            region$remoteness_resid, region$spin_resid))

    plots_list[[i]] <- p
  }

  combined <- grid.arrange(grobs = plots_list, ncol = 2,
                          top = "Same Remoteness & Spin (Resid), Different Disconnection")
  ggsave(file.path(figure_dir, "exemplar_pair_triple.png"), combined,
         width = 16, height = 8)
} else {
  cat("No triple match found with current tolerance\n")
}

# Visualize distribution of disconnection (residualized) at key quantiles
cat("\n=== VISUALIZING DISCONNECTION DISTRIBUTION ===\n")
quantiles <- c(0, 0.25, 0.5, 0.75, 0.9, 1)
quantile_values <- quantile(pa_sample_shapes$disconnection_index_resid, probs = quantiles, na.rm = TRUE)
quantile_labels <- c("Min", "25th", "50th", "75th", "90th", "Max")

cat("Disconnection (residualized) quantiles:\n")
for (i in 1:length(quantiles)) {
  cat(sprintf("  %s: %.3f\n", quantile_labels[i], quantile_values[i]))
}

# Find regions closest to each quantile
quantile_plots <- list()
for (i in 1:length(quantiles)) {
  # Find closest region to this quantile
  idx <- which.min(abs(pa_sample_shapes$disconnection_index_resid - quantile_values[i]))
  region <- pa_sample_shapes[idx, ]

  pts <- sample_interior_points(region$geometry, n_points = 100)
  centroid <- st_centroid(region$geometry)

  p <- ggplot() +
    geom_sf(data = region, fill = "lightblue", color = "darkblue", linewidth = 0.8) +
    geom_sf(data = pts, color = "red", size = 0.8, alpha = 0.5) +
    geom_sf(data = centroid, color = "darkgreen", size = 2, shape = 17) +
    theme_minimal() +
    theme(plot.title = element_text(size = 10),
          plot.subtitle = element_text(size = 8)) +
    labs(title = sprintf("%s (%.2f)", quantile_labels[i], region$disconnection_index_resid),
         subtitle = sprintf("Raw: %.2f km | Area: %.1f km²",
                           region$disconnection_index, region$area_km2))

  quantile_plots[[i]] <- p
}

combined_quantiles <- grid.arrange(grobs = quantile_plots, ncol = 3,
                                  top = "Disconnection Index (Residualized) Distribution")
ggsave(file.path(figure_dir, "disconnection_quantiles.png"), combined_quantiles,
       width = 18, height = 12)


bunch_test_dir = file.path(figure_dir, 'weird_bunching')
if (!dir.exists(bunch_test_dir)) dir.create(bunch_test_dir, recursive = TRUE)
weird_bunching = pa_sample_shapes %>% filter(abs(disconnection_index - 0.01) < 0.001)
for (i in 1:nrow(weird_bunching)) {
  # Find closest region to this quantile
  region <- weird_bunching[i, ]

  pts <- sample_interior_points(region$geometry, n_points = 100)
  centroid <- st_centroid(region$geometry)

  p <- ggplot() +
    geom_sf(data = region, fill = "lightblue", color = "darkblue", linewidth = 0.8) +
    geom_sf(data = pts, color = "red", size = 0.8, alpha = 0.5) +
    geom_sf(data = centroid, color = "darkgreen", size = 2, shape = 17) +
    theme_minimal() +
    theme(plot.title = element_text(size = 10),
          plot.subtitle = element_text(size = 8)) +
    labs(title =  sprintf("Name %s | Country: %s | Area: %.1f km²",
                           region$siteName, region$cddaCountr, region$area_km2))

  ggsave(file.path(bunch_test_dir, sprintf("weird_bunching_region_%d.png", i)), p,
         width = 6, height = 5)
}