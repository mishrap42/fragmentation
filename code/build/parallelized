if (!require('binsreg')) install.packages("binsreg")

library(here)        # Manage file paths relative to project root
library(sf)          # Spatial data handling (reading shapefiles, geometric operations)
library(ggplot2)     # Data visualization and plotting
library(dplyr)       # Data manipulation (filtering, grouping, summarizing)
library(gridExtra)   # Arrange multiple plots side-by-side
library(readxl)      # Read Excel files
library(binsreg)     # Binned regression plots
library(lubridate)   # Date/time manipulation
library(Hmisc)       # Miscellaneous data analysis functions
library(fixest)      # Fast fixed-effects regressions
library(countrycode) # Convert country codes/names
library(parallel)

if (grepl("ahaanj", here())) {
  dropbox_dir <- "/Users/ahaanj/Dartmouth College Dropbox/Ahaan Jindal/Protected Area Fragmentation/"
} else if (grepl("mishrap", here())) {
  dropbox_dir <- "/Users/mishrap/Dropbox (Personal)/Protected Area Fragmentation/"
} else {
  stop("Username not recognized. Please update the script with your Dropbox path.")
}

intermediate_data_dir = file.path(dropbox_dir, 'Data/build')
figure_dir = file.path(dropbox_dir, 'Figures', '1_calculate_shapes')
if (!dir.exists(figure_dir)) dir.create(figure_dir, recursive = TRUE)

pa <- st_read(paste0(dropbox_dir, 'Data/raw/protected sites/protectedsites.shp'))

# Get a stratified sample - 50 areas from each country
set.seed(123)
pa_sample <- pa %>%
  group_by(legalFound, cddaCountr) %>%
  slice_sample(n = 5) %>%
  ungroup()

cat("Total sampled areas:", nrow(pa_sample), "\n")

print('Country counts: validation of sampling')
pa_sample %>% st_drop_geometry() %>% group_by(cddaCountr) %>% summarize(n = n()) %>% print(n = Inf)

print('Foundation year counts:')
pa_sample %>% st_drop_geometry() %>% group_by(legalFound) %>% summarize(n = n()) %>% print(n = Inf)

print('Checking shape validity:')
pa_sample$valid <- st_is_valid(pa_sample)
sprintf('Number of valid geometries: %d out of %d\n', sum( (pa_sample %>% st_drop_geometry())$valid), nrow(pa_sample))

# ========== NINA'S SHAPE METRICS - CORRECTED IMPLEMENTATION ==========
# All require sampling points and computing pairwise distances

# Function to sample interior points from a polygon
sample_interior_points <- function(geom, n_points = 100) {
  # Generate random points inside the polygon
  points <- st_sample(geom, size = n_points, type = "random")
  return(points)
}

# Function to sample perimeter points from a polygon
sample_perimeter_points <- function(geom, n_points = 100) {
  # Cast to linestring and sample along the boundary
  boundary <- st_cast(st_boundary(geom), "LINESTRING")
  points <- st_line_sample(boundary, n = n_points)
  # st_line_sample returns multipoint, convert to individual points
  points <- st_cast(points, "POINT")
  return(points)
}

# Calculate shape metrics for all protected areas
pa_sample <- pa_sample %>%
  mutate(
    area_km2 = as.numeric(units::set_units(st_area(geometry), "km^2")),
    perimeter_km = as.numeric(units::set_units(st_length(st_cast(geometry, "MULTILINESTRING")), "km"))
  ) 

pa_centroid = pa_sample %>% st_centroid() %>% st_coordinates() %>% as.data.frame()

point_sample = sample_interior_points(pa_sample$geometry[1], n_points = 100)

# Visualize sampled points and centroid for the first polygon
p <- ggplot() + geom_sf(data = pa_sample[1,], fill = "lightgreen", color = "darkgreen") +
  geom_sf(data = point_sample, color = "red", size = 2) +
  geom_point(data = as.data.frame(pa_centroid[1,]), aes(x = X, y = Y), color = "blue", size = 3) +
  theme_minimal()
ggsave(file.path(figure_dir, "example_point_sampling.png"), p, width = 8, height = 6)

# P. 3 of Nina's appendix:
dist_matrix = units::set_units(st_distance(point_sample, point_sample), "km")
example_disconnection_index = sum(dist_matrix, na.rm = TRUE) / (nrow(dist_matrix) * (nrow(dist_matrix) - 1))

# Process in chunks of 100. TODO: parallelize this.

# Function to process one chunk
chunk_size <- 100
n_total <- nrow(pa_sample)
n_chunks <- ceiling(n_total / chunk_size)
pa_sample_shapes <- list()

for (i in 1:2) {  # Test with 2 first
  start_idx <- (i - 1) * chunk_size + 1
  end_idx <- min(i * chunk_size, n_total)
  
  cat(sprintf("Processing chunk %d of %d (rows %d to %d)...\n", i, n_chunks, start_idx, end_idx))
  
  chunk_result <- pa_sample[start_idx:end_idx, ] %>%
    rowwise() %>%
    mutate(
      disconnection_index = {
        interior_pts <- sample_interior_points(geometry, n_points = 100)
        if (length(interior_pts) < 2) {
          NA_real_
        } else {
          dist_matrix <- units::set_units(st_distance(interior_pts, interior_pts), "km")
          as.numeric(sum(dist_matrix, na.rm = TRUE) / (nrow(dist_matrix) * (nrow(dist_matrix) - 1)))
        }
      },
      
      remoteness = {
        interior_pts <- sample_interior_points(geometry, n_points = 100)
        centroid <- st_centroid(geometry)
        if (length(interior_pts) < 1) {
          NA_real_
        } else {
          distances <- units::set_units(st_distance(interior_pts, centroid), "km")
          as.numeric(mean(distances, na.rm = TRUE))
        }
      },
      
      spin = {
        interior_pts <- sample_interior_points(geometry, n_points = 100)
        centroid <- st_centroid(geometry)
        if (length(interior_pts) < 1) {
          NA_real_
        } else {
          distances <- units::set_units(st_distance(interior_pts, centroid), "km")
          as.numeric(mean(distances^2, na.rm = TRUE))
        }
      },
      
      range_km = {
        perimeter_pts <- sample_perimeter_points(geometry, n_points = 100)
        if (length(perimeter_pts) < 2) {
          NA_real_
        } else {
          dist_matrix <- units::set_units(st_distance(perimeter_pts, perimeter_pts), "km")
          as.numeric(max(dist_matrix, na.rm = TRUE))
        }
      }
    ) %>%
    ungroup()
  
  pa_sample_shapes[[i]] <- chunk_result
}

pa_sample_shapes <- bind_rows(pa_sample_shapes)

st_write(pa_sample_shapes, paste0(intermediate_data_dir, '/pa_sample_shapes.shp'), delete_dsn = TRUE)

View(pa_sample_shapes)

# Create list of plots
metrics <- list(
  list(col = "disconnection_index", title = "Disconnection", fill = "lightblue"),
  list(col = "remoteness", title = "Remoteness", fill = "lightcoral"),
  list(col = "spin", title = "Spin", fill = "lightgreen"),
  list(col = "range_km", title = "Range", fill = "lightyellow")
)

plots <- lapply(metrics, function(m) {
  pa_sample_shapes %>% st_drop_geometry() %>% filter(!!sym(m$col) > 0) %>%
    ggplot(aes(x = !!sym(m$col))) + 
    geom_histogram(bins = 30, fill = m$fill, color = "black") +
    scale_x_log10() + theme_minimal() + 
    labs(title = m$title, x = "km (log)", y = "Count")
})

grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_histogram_grid.png"), grid_plot, width = 12, height = 10)

# Compare the actual values
pa_sample_shapes %>%
  st_drop_geometry() %>%
  select(disconnection_index, remoteness, spin, range_km) %>%
  summary()

# Add countryname once
pa_sample_shapes$countryname <- countrycode(pa_sample_shapes$cddaCountr, origin = 'eurostat', destination = 'country.name')

# 1. Histograms (already done)
metrics <- list(
  list(col = "disconnection_index", title = "Disconnection", fill = "lightblue"),
  list(col = "remoteness", title = "Remoteness", fill = "lightcoral"),
  list(col = "spin", title = "Spin", fill = "lightgreen"),
  list(col = "range_km", title = "Range", fill = "lightyellow")
)

plots <- lapply(metrics, function(m) {
  pa_sample_shapes %>% st_drop_geometry() %>% filter(!!sym(m$col) > 0) %>%
    ggplot(aes(x = !!sym(m$col))) + 
    geom_histogram(bins = 30, fill = m$fill, color = "black") +
    scale_x_log10() + theme_minimal() + 
    labs(title = m$title, x = "km (log)", y = "Count")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_histograms.png"), grid_plot, width = 12, height = 10)

# 2. Mean by Country (2x2)
plots <- lapply(metrics, function(m) {
  pa_sample_shapes %>%
    st_drop_geometry() %>%
    group_by(countryname) %>%
    summarise(mean_val = mean(!!sym(m$col), na.rm = TRUE)) %>%
    ggplot(aes(x = reorder(countryname, mean_val), y = mean_val)) +
    geom_col(fill = m$fill, color = "black") +
    coord_flip() + theme_minimal() +
    labs(title = m$title, x = "", y = "")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_by_country.png"), grid_plot, width = 14, height = 12)

# 3. Trend over time (2x2)
plots <- lapply(metrics, function(m) {
  pa_sample_shapes %>%
    filter(legalFound > 0 & legalFound < 2030) %>%
    st_drop_geometry() %>%
    group_by(legalFound) %>%
    summarise(mean_val = mean(!!sym(m$col), na.rm = TRUE)) %>%
    ggplot(aes(x = legalFound, y = mean_val)) +
    geom_col(fill = m$fill, color = "black") +
    theme_minimal() +
    labs(title = m$title, x = "Year", y = "")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_by_year.png"), grid_plot, width = 12, height = 10)


# 4. Area-Residualized by Country (2x2)
plots <- lapply(metrics, function(m) {
  resid_model <- feols(as.formula(paste(m$col, "~ i(countryname) + log(area_km2) - 1")),
                       data = pa_sample_shapes %>% st_drop_geometry() %>% 
                         filter(legalFound > 0 & legalFound < 2030))
  
  country_coefs <- data.frame(
    countryname = gsub("countryname::", "", names(coef(resid_model))[grepl("countryname", names(coef(resid_model)))]),
    residualized = coef(resid_model)[grepl("countryname", names(coef(resid_model)))]
  )
  
  country_coefs %>%
    ggplot(aes(x = reorder(countryname, residualized), y = residualized)) +
    geom_col(fill = m$fill, color = "black") +
    coord_flip() + theme_minimal() +
    labs(title = m$title, x = "", y = "")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_residualized.png"), grid_plot, width = 14, height = 12)

# 5. Decomposition Stacked (2x2)
plots <- lapply(metrics, function(m) {
  # Get mean by country
  country_mean <- pa_sample_shapes %>%
    st_drop_geometry() %>%
    group_by(countryname) %>%
    summarise(mean_val = mean(!!sym(m$col), na.rm = TRUE))
  
  # Get residualized
  resid_model <- feols(as.formula(paste(m$col, "~ i(countryname) + log(area_km2) - 1")),
                       data = pa_sample_shapes %>% st_drop_geometry() %>% 
                         filter(legalFound > 0 & legalFound < 2030))
  
  country_coefs <- data.frame(
    countryname = gsub("countryname::", "", names(coef(resid_model))[grepl("countryname", names(coef(resid_model)))]),
    residualized = coef(resid_model)[grepl("countryname", names(coef(resid_model)))]
  )
  
  # Merge and decompose
  decomp <- country_mean %>%
    left_join(country_coefs, by = "countryname") %>%
    mutate(
      area_effect = mean_val - residualized,
      true_effect = residualized
    )
  
  decomp_long <- rbind(
    decomp %>% mutate(component = "true_effect", value = true_effect),
    decomp %>% mutate(component = "area_effect", value = area_effect)
  )
  
  decomp_long %>%
    ggplot(aes(x = reorder(countryname, mean_val), y = value, fill = component)) +
    geom_col() +
    coord_flip() +
    scale_fill_manual(values = c("true_effect" = "steelblue", "area_effect" = "coral")) +
    theme_minimal() +
    theme(legend.position = "none") +
    labs(title = m$title, x = "", y = "")
})
grid_plot <- grid.arrange(grobs = plots, ncol = 2)
ggsave(file.path(figure_dir, "all_metrics_decomposition.png"), grid_plot, width = 14, height = 12)
