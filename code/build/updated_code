library(here)
library(sf)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(readxl)

# This stores your repository path as a function "here()"
if (grepl("ahaanj", here())) {
  dropbox_dir <- "/Users/ahaanj/Dartmouth College Dropbox/Ahaan Jindal/Protected Area Fragmentation/"
} else if (grepl("mishrap", here())) {
  dropbox_dir <- "/Users/mishrap/Dropbox (Personal)/Protected Area Fragmentation/"
} else {
  stop("Username not recognized. Please update the script with your Dropbox path.")
}

# Read in the shapefile of protected areas
pa <- st_read(paste0(dropbox_dir, 'Data/protected sites/protectedsites.shp'))

# Get a stratified sample - 50 areas from each country
set.seed(123)
pa_sample <- pa %>%
  group_by(cddaCountr) %>%
  slice_sample(prop = 1) %>%
  slice_head(n = 50) %>%
  ungroup()

cat("Total sampled areas:", nrow(pa_sample), "\n")

# Save it
saveRDS(pa_sample, paste0(dropbox_dir, "Data/pa_sample_stratified_50.rds"))

# Map it
ggplot(pa_sample) +
  geom_sf(fill = "darkgreen", color = "black", alpha = 0.6, size = 0.1) +
  theme_minimal() +
  labs(title = "Stratified Sample of European Protected Areas")

# ========== NINA'S SHAPE METRICS - CORRECTED IMPLEMENTATION ==========
# These metrics are based on Angel, Civco, and Parent (2009/2010)
# All require sampling points and computing pairwise distances

library(sf)
library(dplyr)

# Function to sample interior points from a polygon
sample_interior_points <- function(geom, n_points = 100) {
  # Generate random points inside the polygon
  points <- st_sample(geom, size = n_points, type = "random")
  return(points)
}

# Function to sample perimeter points from a polygon
sample_perimeter_points <- function(geom, n_points = 100) {
  # Cast to linestring and sample along the boundary
  boundary <- st_cast(st_boundary(geom), "LINESTRING")
  points <- st_line_sample(boundary, n = n_points)
  # st_line_sample returns multipoint, convert to individual points
  points <- st_cast(points, "POINT")
  return(points)
}

# ========== CALCULATE NINA'S SHAPE METRICS ==========
pa_shapes <- pa_sample %>%
  mutate(
    # Basic measurements for reference
    area_km2 = as.numeric(st_area(geometry)) / 1e6,
    perimeter_km = as.numeric(st_length(st_cast(geometry, "MULTILINESTRING"))) / 1000
  ) %>%
  rowwise() %>%
  mutate(
    # Calculate centroid for remoteness and spin
    centroid = list(st_centroid(geometry)),
    
    # 1. DISCONNECTION INDEX
    # Average Euclidean distance between all pairs of interior points
    disconnection_index = {
      interior_pts <- sample_interior_points(geometry, n_points = 100)
      
      if (length(interior_pts) < 2) {
        NA_real_
      } else {
        # Calculate distance matrix between all pairs
        dist_matrix <- st_distance(interior_pts, interior_pts)
        # Convert to numeric and get upper triangle (exclude diagonal)
        dist_values <- as.numeric(dist_matrix[upper.tri(dist_matrix)])
        # Return average distance in km
        mean(dist_values, na.rm = TRUE) / 1000
      }
    },
    
    # 2. REMOTENESS INDEX
    # Average distance from all interior points to centroid
    remoteness = {
      interior_pts <- sample_interior_points(geometry, n_points = 100)
      
      if (length(interior_pts) < 1) {
        NA_real_
      } else {
        # Calculate distances from each interior point to centroid
        distances <- st_distance(interior_pts, centroid[[1]])
        # Return average distance in km
        mean(as.numeric(distances), na.rm = TRUE) / 1000
      }
    },
    
    # 3. SPIN INDEX
    # Average distance from perimeter points to centroid
    spin = {
      perimeter_pts <- sample_perimeter_points(geometry, n_points = 100)
      
      if (length(perimeter_pts) < 1) {
        NA_real_
      } else {
        # Calculate distances from each perimeter point to centroid
        distances <- st_distance(perimeter_pts, centroid[[1]])
        # Return average distance in km
        mean(as.numeric(distances), na.rm = TRUE) / 1000
      }
    },
    
    # 4. RANGE INDEX
    # Average distance between all pairs of perimeter points
    range_km = {
      perimeter_pts <- sample_perimeter_points(geometry, n_points = 100)
      
      if (length(perimeter_pts) < 2) {
        NA_real_
      } else {
        # Calculate distance matrix between all pairs
        dist_matrix <- st_distance(perimeter_pts, perimeter_pts)
        # Get upper triangle (exclude diagonal)
        dist_values <- as.numeric(dist_matrix[upper.tri(dist_matrix)])
        # Return average distance in km
        mean(dist_values, na.rm = TRUE) / 1000
      }
    }
  ) %>%
  ungroup() %>%
  select(-centroid)  # Remove centroid column

cat("Calculated Nina's shape metrics for", nrow(pa_shapes), "protected areas\n")
cat("Note: All indices are in kilometers and based on sampled points\n")

View(st_drop_geometry(pa_shapes))

# Summary by country
shape_summary <- pa_shapes %>%
  st_drop_geometry() %>%
  group_by(cddaCountr) %>%
  summarize(
    n_sampled = n(),
    mean_area = mean(area_km2, na.rm = TRUE),
    mean_disconnection = mean(disconnection_index, na.rm = TRUE),
    mean_remoteness = mean(remoteness, na.rm = TRUE),
    mean_spin = mean(spin, na.rm = TRUE),
    mean_range = mean(range_km, na.rm = TRUE)
  ) %>%
  arrange(desc(mean_area))

View(shape_summary)

# ========== FIND EXTREMES FOR EACH METRIC ==========

# 1. DISCONNECTION INDEX (higher = more spread out internally)
most_disconnected <- pa_shapes %>%
  st_drop_geometry() %>%
  arrange(desc(disconnection_index)) %>%
  select(cddaId, siteName, cddaCountr, disconnection_index, area_km2) %>%
  head(2)

least_disconnected <- pa_shapes %>%
  st_drop_geometry() %>%
  arrange(disconnection_index) %>%
  select(cddaId, siteName, cddaCountr, disconnection_index, area_km2) %>%
  head(2)

# 2. REMOTENESS (higher = farther from center on average)
most_remote <- pa_shapes %>%
  st_drop_geometry() %>%
  arrange(desc(remoteness)) %>%
  select(cddaId, siteName, cddaCountr, remoteness, area_km2) %>%
  head(2)

least_remote <- pa_shapes %>%
  st_drop_geometry() %>%
  arrange(remoteness) %>%
  select(cddaId, siteName, cddaCountr, remoteness, area_km2) %>%
  head(2)

# 3. SPIN (higher = perimeter is farther from center)
highest_spin <- pa_shapes %>%
  st_drop_geometry() %>%
  arrange(desc(spin)) %>%
  select(cddaId, siteName, cddaCountr, spin, area_km2) %>%
  head(2)

lowest_spin <- pa_shapes %>%
  st_drop_geometry() %>%
  arrange(spin) %>%
  select(cddaId, siteName, cddaCountr, spin, area_km2) %>%
  head(2)

# 4. RANGE (higher = larger perimeter extent)
largest_range <- pa_shapes %>%
  st_drop_geometry() %>%
  arrange(desc(range_km)) %>%
  select(cddaId, siteName, cddaCountr, range_km, area_km2) %>%
  head(2)

smallest_range <- pa_shapes %>%
  st_drop_geometry() %>%
  arrange(range_km) %>%
  select(cddaId, siteName, cddaCountr, range_km, area_km2) %>%
  head(2)

# PRINT ALL RESULTS
cat("\n========== DISCONNECTION INDEX ==========\n")
cat("Economic interpretation: Average internal travel distance\n")
cat("\nMOST DISCONNECTED (largest internal distances):\n")
print(most_disconnected)
cat("\nLEAST DISCONNECTED (smallest internal distances):\n")
print(least_disconnected)

cat("\n========== REMOTENESS ==========\n")
cat("Economic interpretation: Average distance to center\n")
cat("\nMOST REMOTE (farthest from center):\n")
print(most_remote)
cat("\nLEAST REMOTE (closest to center):\n")
print(least_remote)

cat("\n========== SPIN ==========\n")
cat("Economic interpretation: Average boundary-to-center distance\n")
cat("\nHIGHEST SPIN (boundary far from center):\n")
print(highest_spin)
cat("\nLOWEST SPIN (boundary close to center):\n")
print(lowest_spin)

cat("\n========== RANGE ==========\n")
cat("Economic interpretation: Average boundary extent\n")
cat("\nLARGEST RANGE (biggest boundary extent):\n")
print(largest_range)
cat("\nSMALLEST RANGE (smallest boundary extent):\n")
print(smallest_range)

# ========== VISUALIZE EXAMPLE ==========
specific_id <- largest_range$cddaId[1]
pa_single <- pa_shapes %>% filter(cddaId == specific_id)

ggplot(pa_single) +
  geom_sf(fill = "lightgreen", color = "darkgreen", size = 1) +
  theme_minimal() +
  labs(
    title = paste("Example:", pa_single$siteName),
    subtitle = paste("Country:", pa_single$cddaCountr)
  )

cat("\n=== EXAMPLE AREA METRICS ===\n")
cat("Site Name:", pa_single$siteName, "\n")
cat("Country:", pa_single$cddaCountr, "\n")
cat("Area:", round(pa_single$area_km2, 2), "kmÂ²\n")
cat("Disconnection Index:", round(pa_single$disconnection_index, 3), "km (avg internal distance)\n")
cat("Remoteness:", round(pa_single$remoteness, 3), "km (avg distance to center)\n")
cat("Spin:", round(pa_single$spin, 3), "km (avg boundary-to-center distance)\n")
cat("Range:", round(pa_single$range_km, 3), "km (avg boundary extent)\n")
